\documentclass[11pt, lettersize, notitlepage, leqno, footskip=0.6cm]{article}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}	
%\usepackage{graphicx}
\usepackage{amscd}
%\usepackage{mathabx}
%\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%\SetKwComment{Comment}{$\triangleright$\ }{}

%\usepackage[T1]{fontenc}% http://ctan.org/pkg/fontenc
%\usepackage[outline]{contour}% http://ctan.org/pkg/contour
%\usepackage{xcolor}% http://ctan.org/pkg/xcolor

\usepackage{authblk}

\usepackage{fancyvrb}

\usepackage[nodisplayskipstretch]{setspace}

% This the preamble, load any packages you're going to use here
%\usepackage{physics} % provides lots of nice features and commands often used in physics, it also loads some other packages (like AMSmath)
%\usepackage{siunitx} % typesets numbers with units very nicely
\usepackage{enumerate} % allows us to customize our lists
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{tikz}
%\usetikzlibrary{decorations.pathreplacing}
%\usepackage[colorinlistoftodos]{todonotes}
%\usepackage{pgfplots} 
%\pgfplotsset{width=10cm,compat=1.9} 
\usepackage{verbatim}

\usepackage{thmtools}
\usepackage[none]{hyphenat}

\usepackage{indentfirst}

\usepackage{braket}

\usepackage[shortlabels]{enumitem}

\usepackage{appendix}



\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}
\DeclareMathAccent{\wideparen}{0}{mathx}{"75}

\def\cs#1{\texttt{\char`\\#1}}



\addtolength{\textwidth}{100pt}
\addtolength{\evensidemargin}{-50pt}
\addtolength{\oddsidemargin}{-50pt}
\addtolength{\topmargin}{-60pt}
\addtolength{\textheight}{1.5in}
%\setlength{\parindent}{0in}
\setlength{\parskip}{0.75pt}


\setlength{\abovedisplayskip}{0cm}
\setlength{\belowdisplayskip}{0cm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Begin user defined commands


\newcommand{\bc}{\mathbb C}
\newcommand{\bF}{\mathbb F}
\newcommand{\bH}{\mathbb H}
\newcommand{\bn}{\mathbb N}
\newcommand{\bz}{\mathbb Z}
\newcommand{\bp}{\mathbb{P}}
\newcommand{\bq}{\mathbb Q}
\newcommand{\br}{\mathbb R}
\newcommand{\bS}{\mathbb S}

\newcommand{\bFp}{\mathbb{F}_p}
\newcommand{\bFP}{\ov{\mathbb{F}}_p}
\newcommand{\bFl}{\mathbb{F}_l}
\newcommand{\bFq}{\mathbb{F}_q}
\newcommand{\bFQ}{\ov{\mathbb{F}}_q}
\newcommand{\bFpk}{\mathbb{F}_{p^k}}


\newcommand{\pl}{\prod\limits}
\newcommand{\slim}{\sum\limits}
\newcommand{\bcup}{\bigcup\limits}
\newcommand{\bcap}{\bigcap\limits}

\newcommand{\ttt}{\texttt}

\newcommand{\bT}{\mathbf T}
\newcommand{\bTl}{\mathbf T_{{\bq_l}}}
\newcommand{\bTlbar}{\mathbf T_{{\qbar_l}}}

\newcommand{\G}{\mathcal G}

\newcommand{\Gal}{\mathrm{Gal}}
\newcommand{\scl}{\mathcal L}

\newcommand{\W}{\mathcal W}
\newcommand{\WA}{\mathcal{W}_{A_v}}

\newcommand{\zbar}{\overline {\mathbb{Z}}}
\newcommand{\qbar}{\overline {\mathbb{Q}}}

\newcommand{\Fbar}{\overline {F}}
\newcommand{\Kbar}{\overline {K}}

\newcommand{\bark}{\overline {k}}

\newcommand{\bg}{\mathbb{G}}
\newcommand{\bG}{\mathbb{G}}

\newcommand{\st}{\mathrm{st}}

\newcommand{\uni}{\mathrm{uni}}

\newcommand{\lcm}{\mathrm{lcm}}

\newcommand{\negl}{\ttt{{negl}}}

\newcommand{\pr}{\protect}

\newcommand{\Acc}{\mbf{Acc}}

\newcommand{\sett}{\ttt{Set}}

\newcommand{\mult}{\mr{mult}}
\newcommand{\mul}{\mr{mult}}


\newcommand{\absq}{\mathrm{Gal}_{\bq}}
\newcommand{\absql}{\mathrm{Gal}_{\bq_l}}
\newcommand{\absqp}{\mathrm{Gal}_{\bq_p}}
\newcommand{\absqph}{\mathrm{Gal}_{\bq_{p^h}}}

\newcommand{\absf}{\mathrm{Gal}_F}
\newcommand{\absfv}{\mathrm{Gal}_{F_v}}
\newcommand{\abse}{\mathrm{Gal}_E}
\newcommand{\absk}{\mathrm{Gal}_K}
\newcommand{\absl}{\mathrm{Gal}_L}


\newcommand{\Gm}{\mathbb{G}_m}

\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\rarrrow}{\rightarrow}
\newcommand{\lra}{\longrightarrow}
\newcommand{\llra}{\longleftrightarrow}
\newcommand{\xra}{\xrightarrow}
\newcommand{\hra}{\hookrightarrow}
\newcommand{\LRA}{\Longleftrightarrow}
\newcommand{\RA}{\Longrightarrow}
\newcommand{\harrow}{\hookrightarrow}
\newcommand{\lhra}{\hooklongrightarrow}

\newcommand{\imp}{\Longrightarrow}

\newcommand{\impop}{\overset{\;\;\;\;\mr{o.p.}\;\;\;\;}{\Longrightarrow}}

\newcommand{\eqlam}{\equiv_{\lam}}

\newcommand{\lameq}{\equiv_{\lam}}


\newcommand{\bs}{\backslash}
\newcommand{\ti}{\tilde}
\newcommand{\wti}{\widetilde}
\newcommand{\mf}{\mathfrak}
\newcommand{\mc}{\mathcal}
\newcommand{\mb}{\mathbb}
\newcommand{\mbf}{\mathbf} 
\newcommand{\mr}{\mathrm}
\newcommand{\mfp}{\mathfrak{p}}
\newcommand{\tmfp}{\ti{\mc{P}}}
\newcommand{\mfm}{\mathfrak{m}}
\newcommand{\mfn}{\mathfrak{n}}

\newcommand{\pro}{\protect\verb}


\newcommand{\mfl}{\mathfrak{l}}

\newcommand{\zetamn}{\zeta_{mn}}

\newcommand{\setm}{\setminus}
\newcommand{\sm}{\setminus}

\newcommand{\Br}{\mr{Br}}

\newcommand{\Jac}{\mr{Jac}}

\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\Ga}{\Gamma}
\newcommand{\Gam}{\Gamma}
\newcommand{\lam}{\lambda}
\newcommand{\lamb}{\lambda}
\newcommand{\Lam}{\Lambda}
\newcommand{\Lamb}{\Lambda}
\newcommand{\del}{\delta}
\newcommand{\Del}{\Delta}
\newcommand{\si}{\sigma}
\newcommand{\tsi}{\tilde{\sigma}}
\newcommand{\om}{\omega}
\newcommand{\Om}{\Omega}
\newcommand{\what}{\widehat}
\newcommand{\weck}{\widecheck}


\newcommand{\ov}{\overline}


\newcommand{\bzlam}{\bz_{(\lam)}}

\newcommand{\bzs}{\bz_{\mc{S}}}
\newcommand{\bzS}{\bz_{\mc{S}}}

\newcommand{\sub}{\subseteq}

\newcommand{\nsub}{\nsubseteq}

\newcommand{\dlog}{\mbf{dlog}}

\newcommand{\Prob}{\ttt{Pr}}

\newcommand{\bO}{\mbf{O}}

\newcommand{\mP}{\mc{P}}

\newcommand{\A}{\mc{A}}

\newcommand{\V}{\mc{V}}

\newcommand{\mcM}{\mc{M}}


\newcommand{\Com}{\ttt{Com}}

\newcommand{\vs}{\vspace{-0.15cm}}

\newcommand{\para}{\;\;\;\;\;\;}

\newcommand{\noin}{\noindent}

\newcommand{\op}{overwhelming probability}

\newcommand{\np}{negligible probability}

\newcommand{\non}{non-interactive proof}

\newcommand{\nons}{non-interactive proofs}

\newcommand{\sta}{\stackrel{?}{=}}

\newcommand{\Mod}[1]{\ (\mathrm{mod}\ #1)}

\newcommand{\LCM}{\mbf{lcm}}

\newcommand{\GCD}{\mbf{gcd}}

\newcommand{\intt}{\ttt{int}}

\newcommand{\un}{\ttt{uni}}

\newcommand{\new}{\ttt{new}}

\newcommand{\Ext}{\ttt{Ext}}

\newcommand{\E}{\mc{E}}

\newcommand{\mbr}{\mbf{r}}



%  End user defined commands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% These establish different environments for stating Theorems, Lemmas, Remarks, etc.

\newtheorem{Thm}{Theorem}[section]
\newtheorem{Prop}[Thm]{Proposition}
\newtheorem{Lem}[Thm]{Lemma}
\newtheorem{Corr}[Thm]{Corollary}
\newtheorem{Algo}[Thm]{Algorithm}
\newtheorem{Example}[Thm]{Example}

\newtheorem{Prot}[Thm]{Protocol}

\newtheorem{Def}{Definition}[section]

\newtheorem{Fact}{Fact}[section]

\newtheorem{Ass}{Assumption}[section]

\newtheorem{Rem}[Thm]{Remark}

\declaretheorem{theorem} 
\declaretheoremstyle[%
  spaceabove=-2pt,%
  spacebelow=8pt,%
  headfont=\normalfont\itshape,%
  postheadspace=1em,%
  qed=\qedsymbol%
]{mystyle} 
\declaretheorem[name={Proof},style=mystyle,unnumbered,
]{prf}

\declaretheorem[name={Step},style=bold,unnumbered, %postheadspace=1em,%
qed=\qedsymbol%
]{prf1}

\numberwithin{equation}{section}


%\renewcommand{\labelenumi}{(\alphaph{enumi})}

% End environments 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Now we're ready to start
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\linespread{1.00}




\begin{document}


 
\title{ZK Arguments of Knowledge via hidden order groups}
\author{Steve Thakur}
\affil{}
\date{\vspace{-6ex}}
 
\maketitle

\begin{abstract} We study non-interactive zero- knowledge (HVZK) arguments of knowledge for commitments in groups of hidden order. We provide protocols whereby a Prover can demonstrate certain properties of and relations between committed sets/multisets, with succinct zero-knowledge proofs that are publicly verifiable against the constant-sized commitments. 

If the underlying group of hidden order is an appropriate imaginary quadratic class group or a genus three Jacobian, the argument systems are transparent. Furthermore, since all challenges are public coin, the protocols can be made non-interactive using the Fiat-Shamir heuristic. This is a follow-up to our recent work (\hyperlink{Th20}{[Th20]}).\end{abstract}

\section{\fontsize{12}{12}\selectfont Preliminaries}

\noin We first state some definitions and notations used in this paper. \vspace{0.15cm}

\noin \textbf{Notations:} We denote the security parameter by $\lam$ and the set of all polynomial functions by $\ttt{poly}(\lam)$. A function $\epsilon(\lam)$ is said to be \textit{negligible} - denoted $\epsilon(\lam)\in \ttt{negl}(\lam)$ - if it vanishes faster than the reciprocal of any polynomial. An algorithm $\mc{A}$ is said to be a probabilistic polynomial time  (PPT) algorithm if it is modeled as a Turing machine that runs in time $\ttt{poly}(\lam)$. We denote by $y\gets \mc{A}(x)$ the process of running $\mc{A}$ on input $x$ and assigning the output to $y$. For a set $S$, $\# S$ or $|S|$ denote its cardinality and $x\xleftarrow{\$} S$ denotes selecting $x$ uniformly at random over $S$. For a positive integer $n$, we write $[n]:=\{0,1,\cdots,n-1\}$.  $\ttt{NextPrime}(n)$ denotes the smallest prime $\geq n$. For statements $\mbf{A}$, $\mbf{B}$ we say that $\mbf{A}$ implies $\mbf{B}$ with \op\;  (denoted by $\mbf{A}\impop \mbf{B}$) if \vs $$1 - \ttt{Pr}\big[\mbf{B}\;\big|\;\mbf{A}\big] = \negl(\lam).$$ $\ttt{H}_{\ttt{FS},\lam}$ denotes the hashing algorithm used by the Fiat-Shamir-heuristic. It generates $\lam$-bit primes.

\begin{comment}

\subsection{\fontsize{11}{11}\selectfont Candidates for hidden order groups }

At the moment, there are only three known families of finite abelian groups of unknown order. We briefly discuss them here.\vspace{0.1cm} 

\noin 1. \textbf{RSA groups:} For distinct $1536$-bit primes $p$, $q$, define $N:= pq$. The group $(\bz/N\bz)^*$ has order $\phi(N) = (p-1)(q-1)$ which can only be computed by factorizing $N$. The strong-RSA assumption is believed to hold in the RS group. However, the group does contain the element $-1\Mod{N}$ of a known order $2$. For the adaptive root assumption to hold, the group has to be replaced by its quotient group $(\bz/N\bz)^*/\{\pm 1\}$ of order $\frac{(p-1)(q-1)}{2}.$ 

The RSA groups suffer from the need for a trusted setup. In practice, this can be mitigated by a one-time secure multi-party computation. At the moment, a $3300$-bit RSA modulus yields a security level of $128$-bits.


\noin 2. \textbf{Class groups:} Computing the class group of a number field is a long-standing problem in algorithmic number theory. Hence, class groups are natural candidates for hidden order groups. At the moment, the only class groups that allow for efficient group operations are those of imaginary quadratic fields.

For a square-free integer $d > 0$, the field $\bq(\sqrt{-d})$ has a class group of size roughly $\sqrt{d}$. This group is believed to fulfill the strong-RSA assumption. Furthermore, if $d$ is a prime $\equiv 3 \Mod{4}$, the $2$-torsion group is trivial, which eliminates the possibility of known elements of order $2$. Such a group is believed to fulfill the strong-RSA, low order and $\{2\}$-fractional root assumptions unless the integer $d$ lies within a certain thin set of integers.

A $6656$-bit discriminant $d$ yields a security level of $128$-bits at the moment. Unlike RSA groups, class groups allow for a transparent (trustless) setup. The downside is that for the same level of security, the group operations are roughly 10 times slower than modular multiplication.

\noin 3. \textbf{Jacobians:} Recently, the group of $\bFp$-valued points of the Jacobian of a genus three hyperelliptic curve over a prime field $\bFp$ has been proposed as a candidate (\hyperlink{DGS20}{[DGS20]}). While this idea needs more scrutiny, it seems promising because of the transparent setup, the smaller key sizes and the fact that the group operations are 28 times faster than those in class groups for the same level of security.

For an irreducible polynomial $f(X)\in \bz[X]$ of degree $7$ with Galois group $\mbf{S}_7$ and a prime $p$ such that $f(X)\Mod{p}$ is separable, the hyperelliptic curve $C:Y^2 = f(X)$ over $\bFp$ yields a Jacobian that is resistant to the known attacks. At the moment, such a genus three hyperelliptic Jacobian over a prime field $\bFp$ of bit-size $1100$ allows for a security level of $128$-bits. This group $\Jac(C)(\bFp)$ is roughly of size $p^3$.

Unfortunately, the adaptive root assumption fails in the group $\Jac(C)(\bFp)$. However, the group obtained by replacing it by an appropriate quotient group appears to satisfy the adaptive root assumption and the weaker assumptions such as the fractional root and low order assumptions. 

\end{comment}

\subsection{\fontsize{11}{11}\selectfont Argument Systems }

%Interactive arguments are interactive proofs [GMR85] in which security holds only against a computationally bounded prover. In an interactive argument of knowledge for a relation $\mc{R}$, the prover convinces the verifier that it knows a witness $w$ for a statement $x$ such that $(x,w) \in R$. In this paper, the term \textit{knowledge} means that the argument has \textit{witness-extended emulation}.

An argument system for a relation $\mc{R}\sub \mc{X} \times \mc{W}$ is a triple of randomized polynomial time algorithms $(\ttt{PGen}, \mP, \V)$, where $\ttt{PGen}$ takes an (implicit) security parameter $\lam$ and outputs a common reference string (CRS) $\ttt{pp}$. If the setup algorithm uses only public randomness we say that the setup is transparent and that the CRS is unstructured. The prover $\mP$ takes as input a statement $x \in X$, a witness $w \in W$, and the CRS $\ttt{pp}$. The verifier $\V$ takes as input $\ttt{pp}$ and $x$ and after interactions with $\mP$ outputs $0$ or $1$. We denote the transcript between the prover and the verifier by $\langle\V(\ttt{pp}, x),\mP(\ttt{pp}, x, w)\rangle$ and write $\V(\ttt{pp}, x), \mP(\ttt{pp}, x, w)\rangle = 1$ to indicate that the verifier accepted the transcript. If $\V$ uses only public randomness we say that the protocol is \textit{public coin}.

We now define soundness and knowledge extraction for our protocols. The adversary is modeled as two algorithms $\A_0$ and $\A_1$, where $\A_0$ outputs the instance $x \in \mc{X}$ after $\ttt{PGen}$ is run, and $\A_1$ runs the interactive protocol with the verifier using a state output by $\A_0$. In a slight deviation from the soundness definition used in
statistically sound proof systems, we do not universally quantify over the instance
$x$ (i.e. we do not require security to hold for all input instances $x$). This is due to
the fact that in the computationally-sound setting the instance itself may encode a trapdoor of the common reference string, which can enable the adversary to fool a verifier. Requiring that an efficient adversary outputs the instance $x$ prevents this. In our soundness definition the adversary $\A_1$ succeeds
if he can make the verifier accept when no witness for $x$ exists. For the stronger argument of knowledge definition we require that an extractor with access to $\A_1$'s internal state can extract a valid witness whenever $\A_1$ is convincing. We model this
by enabling the extractor to rewind $\A_1$ and reinitialize the verifier's randomness.



\begin{Def} We say an argument system $(\tt{PGen}, \mP, \V)$ for a relation $\mc{R}$ is \textbf{complete} if for all $(x,w)\in \mc{R}$, \vs $${\tt{Pr}}\big[\langle \V({\tt{pp}}, x)\;,\; \mP({\tt{pp}}, w)\rangle\big) =1\;:\; {\tt{pp}} \xleftarrow{\$} {\tt{PGen}}(\lam) \big]\; = \; 1. $$ \end{Def}

\begin{Def} We say an argument system $({\tt{PGen}}, \mP, \V)$ is \textbf{sound} if $\mP$ cannot forge a fake proof except with negligible probability. \end{Def}

\begin{Def} We say a sound argument system is an \textbf{argument of knowledge} if for any polynomial time adversary $\A$, there exists an extractor $\E$ with access to $\A$'s internal state that can, with \op, extract a valid witness whenever $\A$ is convincing. \end{Def}

\begin{Def} An argument system is \textbf{non-interactive} if it consists of a single round of interaction between $\mP$ and $\V$.\end{Def}

The Fiat-Shamir heuristic \hyperlink{FS87}{([FS87])} can be used to transform interactive public coin argument systems into non-interactive systems. Instead of the Verifier generating the challenges, this function is performed by a public hashing algorithm agreed upon in advance.




\subsection{\fontsize{11}{11}\selectfont Cryptographic assumptions}

\noin The cryptographic protocols make extensive use of groups of unknown order, i.e., groups for
which the order cannot be computed efficiently. Concretely, we require groups for which two hardness assumptions hold. The Strong RSA Assumption \hyperlink{BP97}{([BP97])} roughly states that it is hard to take arbitrary roots of random elements. The much newer Adaptive Root Assumption \hyperlink{Wes19}{([Wes19])} is the dual to the Strong RSA Assumption and states that it is hard to take random roots of arbitrary group elements. Both of these assumptions are believed to hold in generic groups of hidden order (\hyperlink{Wes19}{[Wes18]}, \hyperlink{BBF19}{[BBF19]}, \hyperlink{DGS20}{[DGS20]}).

\vspace{0.1cm}

\begin{Ass} We say that the \hypertarget{ARA}{\textbf{adaptive root} assumption} holds for a group $\mb{G}$ if there is no efficient probabilistic polynomial time $($PPT$)$ adversary $(\mc{A}_0, \mc{A}_1)$ that succeeds in the following task. $\mc{A}_0$ outputs an element $w\in \mb{G}$ and some state. Then a random prime $\ell$ is chosen and $\mc{A}_1(\ell, \tt{state})$ outputs $w^{1/\ell}\in \mb{G}$. \end{Ass}
 

\begin{Ass} For a set $\mc{S}$ of rational primes, we say $\mb{G}$ satisfies the $\mc{S}$-\textbf{strong RSA} assumption if given a random group element $g\in\bG$ and a prime $\ell\notin \mc{S}$, no PPT algorithm $\mc{A}$ is able to compute $($except with negligible probability$)$ the $\ell$-th root of a chosen element $w\in \mb{G}$. When $\mc{S} = \emptyset$, it is called the \hypertarget{RSA}{\textbf{strong RSA}} assumption.\end{Ass}



\begin{Ass} \hypertarget{low order} We say $\mb{G}$ satisfies the \textbf{low order} assumption if no PPT algorithm can generate $($except with negligible probability$)$ an element $a\in\mb{G}\setminus\{1\}$ and an integer $n< 2^{\mr{poly}(\lam)}$ such that $a^n = 1\in \bG$.\end{Ass}

%\begin{Ass} We say $\mb{G}$ satisfies the \textbf{fractional root assumption} if for a randomly generated element $g\in \mb{G}$, a PPT algorithm cannot output $h\in\mb{G}$ and $d_1,d_2\in\bz$ such that \vs $$g^{d_1} = h^{d_2}\;\wedge\; d_2 \nmid d_1$$ except with negligible probability.\end{Ass}

\begin{Ass} For a set $\mc{S}$ of rational primes, we say $\mb{G}$ satisfies the $\mc{S}$-\textbf{fractional root} assumption if for a randomly generated element $g\in \mb{G}$, no PPT algorithm can output $h\in\mb{G}$ and $d_1,d_2\in\bz$ such that \vs $$g^{d_1} = h^{d_2}\;\;\wedge\; \GCD(d_1,d_2) = 1\;\;\wedge\;\;d_2 \text{ has a prime divisor outside } \mc{S} \vs $$ except with negligible probability. When $\mc{S} = \emptyset$, it is called the \textbf{fractional root} assumption. \end{Ass}

Clearly, if $\mc{S}_0\sub \mc{S}$, the $\mc{S}_0$-{fractional root assumption} implies the $\mc{S}$-{fractional root assumption}. For instance, class groups of imaginary quadratic fields are believed to fulfill the $\{2\}$-fractional root assumption although they do not fulfill the (stronger) fractional root assumption. This is because there is a well-known algorithm to compute square roots in imaginary quadratic class groups (\hyperlink{BS96}{[BS96]}). The assumptions bear the following relations: \vs $$\text{\{Adaptive root assumption\} }\imp \text{ \{Low order assumption\} } ,$$ \vspace{-0.6cm} $$\text{\{Low order assumption\}}\;\wedge\;\{\mc{S}\text{-Strong-RSA assumption\} }\imp \;\{\mc{S}\text{-Fractional root assumption\}}. $$

\noin We refer the reader to the appendix of \hyperlink{BBF19}{[BBF19]} for further details.\vspace{0.2cm}

\begin{Def}\label{rational} \hypertarget{rational}{For elements $a, b\in\mb{G}$ and a rational $\al\in\bq$, we say $a^{\al} = b$ with respect to a PPT algorithm $\A$ if $\A$ can generate integers $d_1,d_2\in\bz$ such that:} 

\noin- $\al = {d_1}{d_2}^{-1}$ \\
- $a^{d_1} = b^{d_2}$\\
- $|d_1|,|d_2| < 2^{{\tt{poly}}(\lam)}$. \end{Def}

\noin Note that if a PPT algorithm $\A$ generates an element $a\in\mb{G}$ and distinct rationals ${d_1}{d_2}^{-1},\; {d_3}{d_4}^{-1}$, $(d_i\in\bz)$ such that \vs $$a^{{d_1}{d_2}^{-1}} = a^{{d_3}{d_4}^{-1}}\;\in\bG, \vs $$ then $a^{d_1d_4-d_2d_3} = 1$ and $d_1d_4-d_2d_3\neq 0$. So the low order assumption implies that $\A$ cannot generate such a tuple $(a,d_1,d_2,d_3,d_4)\in \bG\times \bz^4$, except with negligible probability. Furthermore, by Shamir's trick, $a^{\al} = b$ is equivalent to $\A$ being able to generate an element $a_0\in\mb{G}$ and co-prime integers $d_1,d_2$ such that \vs $$\al = {d_1}{d_2}^{-1}\;\;,\;\;a_0^{d_2} =a\;\;,\;\; a_0^{d_1} =b\;,\; \vs $$

\subsubsection{\fontsize{11}{11}\selectfont Generic group models for hidden order groups}

We will use the generic group model for groups of unknown order as defined by \hyperlink{DK02}{[DK02]} and \hyperlink{BBF19}{[BBF19]}. The group is parametrized by two integer public parameters $A, B$. The order of the group is sampled uniformly from  the interval $[A, B]$. The group $\bG$ is defined by a random injective function $\sigma: \bz_{|\bG|}\lra \{0, 1 \}^n$ for some $n>>\log_2(|\bG|)$. A generic group algorithm $\mc{A}$ is a probabilistic algorithm. Let $\mc{L}$ be a list that is initialized with the encodings given to $\A$ as input. The algorithm can query two generic group oracles: \vspace{0.1cm}

\noin $\bullet$ \hypertarget{Oracles}{$\mc{O}_1$} samples a random $r\in \bz_{\bG}$ and returns $\sigma(r)$, which is appended to the list $\mc{L}$ of encodings.

\noin $\bullet$ When $\mc{L}$ has size $q$, the second oracle $\mc{O}_2(i,j,\pm)$ takes two indices $i, j\in\{1,\cdots,q \}$ and a sign bit and returns $\sigma(x_i\pm x_j)$ which is appended to $\mc{L}$.


\subsection{\fontsize{11}{11}\selectfont Multiset notations and operations}


We first recall/introduce a few basic definitions and notations concerning multisets. For a multiset $\mc{M}$, we denote by $\sett(\mc{M})$ the underlying set of $\mc{M}$. For any element $x$, we denote by $\mul(\mc{M},x)$ the multiplicity of $x$ in $\mc{M}$. Thus, $\mc{M} = \{ \mult(\mc{M},x)\times x: \; x\in \sett(\mc{M})\}$. For brevity, we write \vs $$\Pi(\mc{M}):= \pl_{x\in \sett(\mc{M})} x^{\mult(\mc{M},x)}.$$ For two multisets $\mc{M}, \mc{N}$, we have the following operations:\vspace{0.1cm}

\noin - The sum $\mc{M}+\mc{N} := \{(\mul(\mc{M},x)+\mul(\mc{N},x))\times x:\;x\in \sett(\mc{M})\cup\sett(\mc{N}) \}$

\noin - The union $\mc{M}\cup \mc{N} := \{\max(\mul(\mc{M},x),\mul(\mc{N},x))\times x:\;x\in \sett(\mc{M})\cup\sett(\mc{N})\}$

\noin - The intersection $\mc{M}\cap \mc{N} := \{\min(\mul(\mc{M},x),\;\mul(\mc{N},x))\times x:\;x\in \sett(\mc{M})\cup\sett(\mc{N})\}$

\noin - The difference $\mc{M}\sm \mc{N} := \{\min(\mul(\mc{M},x)-\mul(\mc{N},x),\; 0)\times x:\;x\in \sett(\mc{M})\cup\sett(\mc{N})\}$.\vspace{0.1cm}

\noin The function $\Pi(\cdot)$ clearly has the following properties:\vspace{0.05cm}

\noin- $\Pi(\mc{M}+\mc{N})= \Pi(\mc{M})\cdot\Pi(\mc{N})$

\noin - $\Pi(\mc{M}\cup \mc{N}) = \LCM(\Pi(\mc{M}), \Pi(\mc{M}))$

\noin - $\Pi(\mc{M}\cap \mc{N}) = \GCD(\Pi(\mc{M}), \Pi(\mc{M}))$

\noin - $\Pi(\mc{M}\sm \mc{N}) = {\Pi(\mc{M})}/{\Pi(\mc{M}\cap \mc{N})}$\vspace{0.2cm}

\noin \textbf{Multiset Commitments:} For a multiset $\mc{M}$ represented by $\lam$-bit primes and a hidden order group $\bG$, a $\bG$-\textit{commitment to a multiset} $\mc{M}$ is a pair $(g, h)\in\bG^2$ such that $g^{\Pi(\mc{M})} = h$. The hardness of the discrete logarithm problem implies that this commitment is \textit{hiding} in the sense that no PPT algorithm can compute $\mcM$ from the pair $[g,h]$. The low order assumption implies that it is \textit{binding} in the sense that no PPT algorithm can compute another multiset $\mcM'$ with the same commitment.

\subsection{\fontsize{11}{11}\selectfont Cryptographic Accumulators }

A cryptographic accumulator [Bd94] is a primitive that produces a short binding commitment to a set (or multiset) of elements together with short membership and/or non-membership proofs for any element in the set. These proofs can be publicly verified against the commitment. Broadly, there are three known types of accumulators at the moment: 

\noin - Merkle trees\\
- pairing-based (aka bilinear) accumulators \\  
- accumulators based on groups of unknown order, which we study in this paper. 

Let $\mb{G}$ be a group of hidden order and fix an element $g \in\mb{G}$. Let $\mc{M}$ be a multiset of $\lam$-bit primes. For each $x\in \mc{M}$, let $\mult(\mc{M},x)$ denote the multiplicity of $x$ in $\mcM$. The \textit{accumulated digest} or \textit{accumulated state} of $\mc{M}$ is given by \vs $$\Acc(\mc{M}):= \ttt{Com}(g,\mcM) =   g^{\Pi(\mc{M})} \;\in\;\bG,$$ where $$\Pi(\mc{M}) := \pl_{x\in \sett(\mc{M})} x^{\mult(\mc{M},x)} .$$ Let $\mc{M}_0$ be a multiset contained in $\mc{M}$, so that  $\mult(\mc{M}_0,x)\leq \mult(\mc{M},x)\;\forall\;x$. The element \vs $$w(\mc{M}_0):= g^{\pl_{x\in \sett(\mc{M})} x^{\mult(\mc{M}\sm \mc{M}_0 ,x)}}\;\in\;\mb{G} \vs $$ is called \textit{the membership witness} of $\mc{M}_0$. Given this element, a Verifier can verify the membership of $\mc{M}_0$ in $\mc{M}$ by verifying the equation \vspace{-0.2cm} $$w(\mc{M}_0)^{\Pi(\mc{M}_0)} \sta \Acc(\mc{D})\;\in\;\bG. \vs $$ When the multiset $\mc{M}_0$ is large, this verification can be sped up using Wesolowki's \textit{Proof of Exponentiation} (\verb|PoE|) protocol (\hyperlink{Wes18}{[Wes18]}).

Shamir's trick allows for aggregation of membership witnesses in accumulators based on hidden order groups. This is not possible with Merkle trees, which is the primary reason other families of accumulators have been explored as authentication data structures for stateless blockchains. With bilinear accumulators, aggregation of membership witnesses has a linear runtime complexity, which is impractical for most use cases. Thus, accumulators based on hidden order groups have a major advantage in this regard.

These accumulators also allow for non-membership proofs ([LLX07]). In \hyperlink{BBF19}{[BBF19]}, the authors used a non-interactive argument of knowledge to compress batched non-membership proofs into constant-sized proofs, i.e. independent of the number of elements involved. This yields the first known Vector Commitment with constant-sized openings as well as  constant-sized public parameters.\vspace{0.15cm}

\noin \textbf{Hashing the data to primes:} The security of cryptographic accumulators and vector\\ commitments hinges on the assumption that for disjoint data sets $\mc{D},\mc{E}$, the integers $\Pi(\mc{D}), \Pi(\mc{E})$ are relatively prime. The easiest way to ensure this is to map the data elements to distinct $\lam$-bit primes. This is usually done by hashing the data to $\lam$-bit integers and subjecting the output to a probabilistic primality test such as the Miller-Rabin test. The prime number theorem states that the number of primes less than $n$ is $\mbf{O}(\frac{n}{\log(n)})$ and hence, implies that the expected runtime for finding a prime is $\mbf{O}(\lam)$.

Dirichlet's theorem on primes in arithmetic progressions combined with the prime number theorem implies that for relatively prime integers $k,r$ and an integer $n$, the number of primes less than $n$ that are $\equiv r\Mod{k}$ is roughly $\frac{n}{\log(n)\phi(k)}$. Thus, we can modify the hashing algorithm so that for any element inserted into the accumulator, the prime reveals the position in which it was inserted. We proceed as follows.\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vspace{-0.1cm} 

\item Fix a prime $p$ of size $\frac{\lam}{2}$. \vs 

\item For a string inserted in position $i$, we map the string to the first prime of size $\lam$ which is $\equiv i\Mod{p}$. This (pseudo-)prime is obtained by subjecting the integers $\{pk+i:\;k\in\bz\}$ to the probabilistic Miller-Rabin test. \end{enumerate} 

\noin The number of such primes is roughly \vs $\frac{2^{\lam}}{\lam (p-1)}$ and hence, the expected runtime is $\mbf{O}(\lam)$.

\section{\fontsize{11}{11}\selectfont HVZK Proofs}

We first briefly review the protocol $\ttt{ZKPoKE}$ from [BBF19], which we will need repeeatedly in the subsequent protocols. The protocol $\tt{ZKPoKE}$ is an HVZK argument of knowledge for the relation \vs $$\mc{R}_{\tt{PoKE}}:= \big\{\big((u,w)\in \bG);\; x\in \bz\big)\;:\; w = u^x \in \bG  \big\}.$$

\begin{Prot} \normalfont \hypertarget{ZKPoKE}{\textit{Zero knowledge proof of the knowledge of the Exponent}} (\verb|ZKPoKE|):\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Inputs:} Elements $u,w \in \mb{G}$, $B > 2^{2\lam}|\bG|$

\noin \textbf{Claim:} The Prover possesses an integer $x$ such that $u^x = w$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover chooses random $k, \rho_x, \rho_k\in [-B,B]$ and sends $(z, A_g, A_u)$ to the Verifier, where $z:= g^xh^{\rho_x}$, $A_g:= g^kh^{\rho_k}$, $A_u:= u^k$.

\noin 2. The Verifier generates a random $\lam$-bit integer $c$ and a random $\lam$-bit prime $\ell$ and sends them to the Prover.

\noin 3. The Prover computes the integers $q_x$, $q_{\rho}$, $r_x$, $r_{\rho}$ such that \vs $$k+c\cdot \rho_k = q_x\cdot \ell + r_x\;,\; \rho_k+c\cdot \rho_x = q_{\rho}\cdot \ell + r_{\rho} \vs $$ and sends $Q_g:= g^{q_x}h^{q_{\rho}}$, $Q_u:= u^{q_x}$ and $r_x,r_{\rho}$ to the Verifier.

\noin 4. The Verifier accepts if and only if $r_x,r_{\rho}\in [\ell]$ and the equations $Q_g^{\ell}\cdot g^{r_x}h^{r_{\rho}} = A_gz^c$,\\ $Q_u^{\ell}\cdot u^{r_x} = A_u w^{c}  $ hold.\qed \end{enumerate}

\noin Clearly, the relation $\mc{R}_{\tt{PoKE}}$ is transitive in the sense that for elements $a_1,a_2,a_3\in\mb{G}$, if a prover $\mP$ possesses integers $d_1,d_2$ such that $a_1^{d_1} = a_2\;,\;a_2^{d_2} = a_3$, then he possesses the integer $d_1d_2$ which fulfills the equation $a_1^{d_1d_2} = a_3$. Henceforth, we denote the zero-knowledge proof of knowledge of the discrete logarithm between $a,b\in\mb{G}$ by $\verb|ZKPoKE|[a,\;b]$.

In particular, if $a$, $b$ are commitments \vs $$ a = \ttt{Com}(g, \mc{M}) := g^{\Pi(\mcM)}\;\;,\;\;b = \ttt{Com}(g, \mc{N}) := g^{\Pi(\mc{N})}  \vs $$ to sets/multisets $\mcM$, $\mc{N}$ with  a common base $x\in\bG$, the protocol demonstrates that $\mcM\sub \mc{N}$ without revealing anything about $\mcM$ or $\mc{N}$. The protocol can also be adapted to a setting where the commitments to $\mc{M}$, $\mc{N}$ are made perfectly hiding using a Pedersen commitment.

Suppose $a = g^{d}h^{r}$, $b = g^{\wti{d}}h^{\wti{r}}$ where the integers $r$, $\wti{r}$ are randomly selected. We provide an HVZK argument of knowledge for  the following relation:\vs

\[
  \mc{R}_{\ttt{PoKEPed}}[a,b] = \left\{\begin{array}{l}
    ((a, b)\in\mb{G}^2)\\
    (d_1,d_2,r_2,r_2)\in\mb{Z}^4): \\
    a = g^{d_1}h^{r_1},\;b = g^{d_2}h^{r_2}\;\wedge\;d_1\big|d_2  \end{array}\right\}
\] 

\noin Given Pedersen commitments to sets or multisets $\mc{D}_1$, $\mc{D}_2$ such that $\mc{D}_1\cap \mc{D}_2$, the protocol allows a Prover to demonstrate this relation without revealing anything about the $\mc{D}_i$.

\begin{Prot} \normalfont \hypertarget{ZKPoKEPed}{\textit{Zero knowledge proof of the knowledge of the Exponent for Pedersen commitments}} \end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Inputs:} Elements $a,b\in\bG$

\noin \textbf{Claim:} The Prover possesses integers $d_1,d_2$, $r_1,r_2$ such that \vs $$a = g^{d_1}h^{r_1} \;\wedge\; b = g^{d_2}h^{r_2} \;\wedge\; d_2\equiv 0\Mod{d_1} . \vs $$

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ computes the integer $e:= \wti{d}\cdot{d}^{-1}$ and sends $\wti{a}:= a^{e}\in \bG$ to the Verifier $\V$ along with a non-interactive proof for $\ttt{ZKPoKE}[a,\;\wti{a}]$.

\noin 2. $\mP$ computes $\wti{h}:= \wti{a}^{-1}\cdot b\in \bG$ and sends a non-interactive proof for $\ttt{ZKPoKE}[h,\;\wti{h}]$ to $\V$.

\noin 3. $\V$ accepts if and only if both \verb|ZKPoKE|s are valid.\qed \end{enumerate}


  

We now start out with a fairly simple protocol . We show how a Prover could probabilistically demonstrate that two discrete logarithms are equal, with a constant-sized proof. In other words, the protocol allows a Prover to show that two pairs $[a_1, b_1]$, $[a_2, b_2]$ of $\bG$-elements are commitments to the same set/multiset. The protocol is useful whenever we need to compare two discrete logarithms with different bases. We provide an HVZK argument of knowledge for  the following relation:\vs

\[
  \mc{R}_{\ttt{EqDLog}}[(a_1, b_1),\;(a_2,b_2)] = \left\{\begin{array}{l}
    ((a_1, b_1),\; (a_2,b_2)\in\mb{G}^2\\
    d\in\mb{Z}: \\
    (b_1,b_2) = (a_1^d,a_2^d)
  \end{array}\right\}
\] \vspace{0.1cm}

\noin The protocol hinges on the observation that for two integers $d_1,d_2$, if we have $d_1\equiv d_2\Mod{\ell}$ for a randomly generated $\lam$-bit prime $\ell$, then with \op, $d_1= d_2$.

\vspace{0.15cm}

\begin{Prot} \normalfont \hypertarget{EqDLog}{\textit{Zero knowledge proof of equality of discrete logarithms}} (\verb|ZKPoEqDLog|):\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Inputs:} Elements $a_1, a_2, b_1, b_2 \in \mb{G}$, $B > 2^{2\lam}|\bG|$

\noin \textbf{Claim:} The Prover possesses an integer $d$ such that $a_1^{d} = b_1$, $a_2^{d} = b_2$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ chooses random integers $k, \rho_k, \rho_d\in [-B, B] $ and sends the group elements \vs $$\wti{g}:= g^d h^{\rho_d}\;,\; A_g:= g^k h^{\rho_k}\;,\; \what{a}_1:= a_1^{k}\;,\; \what{a}_2:= a_2^k \;\in\;\bG \vs $$ to the Verifier $\V$.

\noin 2. The hashing algorithm $\ttt{H}_{\ttt{FS},\lam}$ generates $\lam$-bit primes $\gamma$, $\ell$.

\noin 3. $\mP$ computes the integers $q_d$, $r_d$, $q_{\rho}$, $r_{\rho}$ such that \vs $$ d\gamma+k = q_d\cdot\ell+r_d\;\;,\;\;\rho_d\cdot \ell + \rho_k = q_{\rho}\cdot \ell + r_{\rho}\;\;,\;\; r_d,r_{\rho}\in[\ell]\vs $$ and sends $r_d,r_{\rho}$ to $\V$.

\noin 4. $\mP$ computes $$Q_g:= g^{q_{d}}h^{q_{\rho}}\;,\; Q_1:= a_1^{q_d}\;,\; Q_2:= a_2^{q_d}\;\in\;\bG \vs $$ and sends $Q_g, Q_1,Q_2$ to $\V$.

\noin 5. $\V$ verifies that $r_d,r_{\rho}\in [\ell]$ and the equations \vs $$Q_g^{\ell}g^{r_d}h^{r_{\rho}}  \sta \wti{g}^{\gamma}A_g\;\;\bigwedge\;\; Q_1^{\ell}a_1^{r_d}\sta \what{a}_1b_1^{\gamma}\;\;\bigwedge\;\; Q_2^{\ell}a_2^{r_d}\sta \what{a}_2b_2^{\gamma}. \vs $$ He accepts if and only if all three equations hold.\qed \end{enumerate}

\bigskip

\noin We provide an HVZK argument of knowledge for the relation 

\[
  \mc{R}_{{\ttt{Prod}}}[(a_1, b_1),\;(a_2,b_2),\;(a_3,b_3)] = \left\{\begin{array}{l}
    \big((a_1, b_1), (a_2,b_2), (a_3,b_3)\in\mb{G}^2);\\
    (d_1, d_2, d_3)\in\mb{Z}^3): \\
    b_i = a_i^{d_i}\;(i=1,2,3)\; \bigwedge\; d_1d_2 = d_3
  \end{array}\right\}
\] 

\vspace{0.1cm}

\begin{Prot} \normalfont \hypertarget{PoProd}{\textit{Zero knowledge proof of product of discrete logarithms}} (\verb|ZKPoProd|):\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Inputs:} Elements $a$, $b_1, b_2, b_3 \in \mb{G}$, $B > 2^{2\lam}|\bG|$

\noin \textbf{Claim:} The Prover possesses integers $d_i$ ($i=1,2,3$) such that $a_i^{d_i} = b_i$ and $d_1d_2 = d_3$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ computes \vs $$b_{1,2}:= a_1^{d_2}\;,\; b_{1,3}:= a_1^{d_3}\;\in\;\bG \vs $$ and sends them to the Verifier $\V$ along with non-interactive proofs for $\ttt{ZKPoEqDLog}[(a_1,b_2),\;(a_2,b_{1,2})]$ and $\ttt{ZKPoEqDLog}[(a_1,b_3),\;(a_3,b_{1,3})]$.

\noin 2. $\mP$ generates a non-interactive proof for $\ttt{ZKPoEqDLog}[(a, b_1),\;(b_{1,2}, b_{1,3})]$ and sends it to $\V$.

\noin 3. $\V$ accepts if an only if all three proofs are valid.\qed\end{enumerate}



\noin We can also generalize the protocol \verb|ZKPoEqDLog| as follows. For a public polynomial {$f(X)\in \bz[X]$}, an honest Prover can provide a constant-sized ZK proof that he possesses integers $d_1,d_2$ such that \vs $$a_1^{d_1} = b_1\;,\;a_2^{d_2} = b_2\;,\;f(d_1) = d_2. $$ We provide an HVZK argument of knowledge for the relation \vs

\[
  \mc{R}_{{\ttt{PolyDLog}}}[(a_1, b_1),\;(a_2,b_2),\;f] = \left\{\begin{array}{l}
    \big((a_1, b_1), (a_2,b_2)\in\mb{G}^2,\;f\in\bz[X]\big);\\
    (d_1, d_2)\in\mb{Z}^2): \\
    b_1 = a_1^{d_1}\; \bigwedge\; b_2 = a_2^{d_1}\; \bigwedge \;d_2 = f(d_1)
  \end{array}\right\}
\] 

\vspace{0.1cm}

The non-ZK argument of knowledge for this relation ([TH20B]) is fairly simple. The Prover sends the remainders $r_i:= d_i\Mod{\ell}$ for a randomly chosen $\lam$-bit prime challenge $\ell$. He verifiably shows that $r_i\equiv d_i\Mod{\ell}$ by sending the $\ell$-th roots of $b_ia_i^{-r_i}$. The Verifier verifies the exponentiations and the congruence $r_2\equiv f(r_1)\Mod{\ell}$.

The zero-knowledge variant is a bit more subtle since it requires a blinding factor. The Prover can no longer send over the remainders $r_i:= d_i\Mod{\ell}$ since such a protocol is inherently \textit{not} zero-knowledge. However, the protocol can be be made zero-knowledge with a modification that hinges on the observation for integers $d_1$, $d_2$,  that the following are equivalent with \op.\vspace{0.1cm}

\noin 1. $d_2 = f(d_1)$\\
\noin 2. $f(d_1)\equiv d_2\Mod{\gamma}$ for a randomly generated $\lam$-bit prime $\gamma$.\\
\noin 3. $d_2 \equiv f(d+k\gamma)\Mod{k\gamma} $ for an integer $k$ chosen by the Prover and a randomly generated $\lam$-bit prime $\gamma$. \vspace{0.1cm}



\begin{Prot} \normalfont \hypertarget{Poly}{\textit{Zero knowledge proof of polynomial relation between discrete logarithms}}\\ (\verb|ZKPoPolyDLog|):\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Inputs:} Elements $a_1,a_2, b_1, b_2,  \in \mb{G}$; a public univariate polynomial $f(X)\in \bz[X]$; $B > 2^{2\lam}|\bG|$

\noin \textbf{Claim:} The Prover possesses integers $d_i$ ($i=1,2$) such that $a_i^{d_i} = b_i$ and $f(d_1) = d_2$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item  The Prover $\mP$ computes $b_{1,2}:= a_1^{d_2}$ and sends it to the Verifier $\V$ along with a non-interactive proof for $\ttt{ZKPoEqDLog}[(a_1,b_{1,2}),\;(a_2,b_2)]$.

\noin 2. $\mP$ chooses a random $k\in[-B,B]$ and sends $A_1:= a_1^{k}$ to $\V$.

\noin 3. The hashing algorithm $\ttt{H}_{\ttt{FS},\lam}$ generates a $\lam$-bit prime $\gamma$.

\noin 4. $\mP$ sends $A_2:= a_1^{f(d_1+k\gamma)}\in\bG$ to $\V$.

\noin 5. The hashing algorithm $\ttt{H}_{\ttt{FS},\lam}$ generates a $\lam$-bit prime $\ell$.

\noin 6. $\mP$ computes the integers $q_1$, $r_1$, $q_2$, $r_2$ such that \vs $$d_1+k\gamma = q_1\cdot \ell + r_1\;,\; f(d_1+k\gamma) = q_2\cdot \ell + r_2\;\;,\;\;r_1,r_2\in [\ell]   \vs $$ and sends $r_1$, $Q_1:= a_1^{q_1}\;,\; Q_2:= a_1^{q_2}$ to $\V$.

\noin 7. $\mP$ generates a non-interactive proof for $\ttt{ZKPoKE}[A_1^{\gamma},\; A_2\cdot b_{1,2}^{-1}]$ and sends it to $\V$.

\noin 8. $\mP$ chooses random $\rho_d,\rho_k\in [-B, B]$ and sends $\wti{g}:= g^d h^{\rho_d}$, $A_g:= g^k h^{\rho_k}\in \bG$ to $\V$.

\noin 9. The hashing algorithm $\ttt{H}_{\ttt{FS},\lam}$ generates $\lam$-bit primes $c$, $\ell_0$. 

\noin 10. $\mP$ computes the integers $q_d$, $r_d$, $q_{\rho}$, $r_{\rho}$ such that \vs $$c\cdot d_1 + k = q_d\cdot \ell_0 + r_d\;,\; c\cdot \rho_d + \rho_k = q_{\rho}\cdot \ell_0 + r_{\rho}\;\;,\;\;r_{\rho},r_d\in [\ell_0] \vs $$ and sends $r_{d}$, $r_{\rho}$, $Q_g:= g^{q_d}h^{q_{\rho}}$, $Q:= a_1^{q_d}$ to $\V$.

\noin 11. $\V$ verifies that $r_{d}, r_{\rho}\in [\ell_0]$, $r_1\in [\ell]$ and computes $r_2:= f(r_1)\Mod{\ell}$.

\noin 12. $\V$ verifies the equations \vs $$Q_1^{\ell}a_1^{r_1} \sta b_1 \cdot A_1^{\gamma}\;\;\bigwedge\;\; Q_2^{\ell}a_2^{r_2} \sta A_2 \;\;\bigwedge\;\; Q_g^{\ell_0}g^{r_d}h^{r_{\rho}}\sta A_1\cdot \wti{g}^c \;\;\bigwedge\;\; Q^{\ell_0}a_1^{r_d}\sta A_1 b_1^c .\vs $$ He accepts if and only if all four equations hold and the proof for $\ttt{ZKPoKE}[A_1^{\gamma},\; A_2\cdot b_{1,2}^{-1}]$ is valid.\qed \end{enumerate}


For instance, the special case of protocol $\ttt{ZKPoPolyDLog}$ where $f(X) = X^n$ for some integer $n$ can be used to show that for a tuple $(a_1, a_2, b_1, b_2)\in \mb{G}^4$, there exists a multiset $\mcM$ such that \vs $$ a_1^{\Pi(\mcM)} = b_1\;\;,\;\; a_2^{\Pi(n\cdot\mcM)} = b_2   \vs $$ without revealing anything about $\mcM$, where $n\cdot\mcM:= \big\{\big(n\cdot \mult(x, \mcM)\big)\times x:\; x\in \sett({\mcM})\big\}.$


\begin{Prop} The protocol $\tt{ZKPoPolyDLog}$ is an HVZK argument of knowledge for the relation $\mc{R}_{\tt{PolyDLog}}$.\end{Prop}

\begin{prf} \end{prf}






\subsection{\fontsize{11}{11}\selectfont Underlying sets of committed multisets}

\noin \hypertarget{Sets}{Let $a_1,a_2$ be elements of $\mb{G}$. Let $\mc{M}$ , $\mc{N}$ be multisets of rational primes.} Let \vs $$A_1:= \ttt{Com}(g, \mc{M}) =  a_1^{\Pi(\mc{M})}\;,\; A_2:= \ttt{Com}(g, \mc{N}) = a_2^{\Pi(\mc{N})}\;\in\;\bG \vs $$ be the commitments to $\mc{M}$, $\mc{N}$ with bases $a_1, a_2\in \bG$.

Clearly, the relation $\mc{N}\sub \mc{M}$ can be demonstrated by the protocol \verb|PoKE|$[A_2, A_1]$. We now show that the protocol \verb|PolyDLog| allows a Prover to succinctly demonstrate the following relations between the underlying sets of $\mc{M}$, $\mc{N}$, the proofs for which can be publicly verified against the commitments to $\mc{M}$ and $\mc{N}$.\vspace{0.1cm}

\noin 1. $\sett(\mc{M})\sub \sett(\mc{N})$.

\noin 2. $\sett(\mc{M})\nsub \sett(\mc{N})$.

\noin 3. $\sett(\mc{M}) = \sett(\mc{N})$ \vspace{0.1cm}

\noin Before we describe the protocols, we note a few basic facts. Clearly, we have \vs $$\sett(\mc{M}) = \sett(\mc{N})\LRA \sett(\mc{M}) \sub \sett(\mc{N})\;\bigwedge\; \sett(\mc{N}) \sub \sett(\mc{M}). \vs $$ Furthermore, with notations as before, we have \vs $$\sett(\mc{M})\sub \sett(\mc{N})\LRA \exists\; N\in\bz\;:\;\Pi(\mc{M})^N\equiv 0\Mod{\Pi(\mc{N})}.\vs $$ Likewise, to show that $\sett(\mc{M})\nsub \sett(\mc{N})$, it suffices to show that there exists an integer $p$ such that \vs $$p\notin \{-1,1\}   \;\;\bigwedge\;\;\Pi(\mc{M})\equiv 0\Mod{p} \;\;\bigwedge\;\; \GCD(\Pi(\mc{N}),{p})=1.$$

\begin{Prot} \hypertarget{Sets}{ZK Proof of containment of underlying sets $(\tt{ZKPoConSets})$.}\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g, h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Input:} Elements $a_1,a_2\in\mb{G}$; commitments $A_1 := \ttt{Com}(a_1, \mc{M}) = a_1^{\Pi(\mc{M})}\;,\;A_2 := \ttt{Com}(a_2, \mc{N})= a_2^{\Pi(\mc{N})}$ to multisets $\mc{M}$, $\mc{N}$.

\noin \textbf{Claim:} $\sett(\mc{N})\sub \sett(\mc{M})$. \vs

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt] \item The Prover $\mP$ computes $N:= \max\{\mr{mult}(\mc{N}, x):x \in \mc{N}\}$ and \vs $$A_3:= a_1^{\Pi(\mc{M})^N}\;\in\;\bG. \vs $$ He sends $A_3$ and $N$ to the Verifier $\V$.

\noin 2. $\mP$ generates a non-interactive proof for \verb|ZKPoPolyDLog|$[(a_1, A_1),\;(a_2, A_3),\;X^N]$ and sends it to $\V$.

\noin 3. $\mP$ generates a non-interactive proof for \verb|ZKPoKE|$[A_2,A_3]$ and sends it to $\V$.

\noin 4. $\V$ verifies the two proofs and accepts if and only if both are valid.\qed \end{enumerate}


\begin{Prot} ZK Protocol for the non-containment of underlying sets $(\tt{ZKPoNonConSets})$.\end{Prot}\vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$. 

\noin \textbf{Input:} Elements $a_1,a_2\in\mb{G}$; commitments $A_1 := \ttt{Com}(a_1, \mc{M}) = a_1^{\Pi(\mc{M})}\;,\;A_2 := \ttt{Com}(a_2, \mc{N})= a_2^{\Pi(\mc{N})}$ to multisets $\mc{M}$, $\mc{N}$.

\noin \textbf{Claim:} $\sett(\mc{M})\nsub \sett(\mc{N})$. \vs

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt] \vs \item The Prover chooses an integer $p\in \sett(\mc{M})\setminus \sett(\mc{N}).$ and computes $b_1: = a_1^p$. He sends $b_1$ to the Verifier $\V$ along with a non-interactive proof for \verb|ZKPoKE|$[b_1, A_1]$.

\noin 2. $\mP$ generates a non-interactive proof for \verb|ZKPoRelPrimeDLog|$[(a_1, b_1),\; (a_2, A_2)]$ and sends it to $\V$.

\noin 3. $\V$ checks that $b_1\notin \{ a_1, a_1^{-1}\}$ and verifies the proofs for \verb|ZKPoRelPrimeDLog|$[(a_1, b_1),\; (a_2, A_2)]$ and \verb|ZKPoKE|$[b_1, A_1]$. He accepts if and only if both proofs are valid.\qed \end{enumerate}









\section{\fontsize{12}{12}\selectfont HVZK arguments for set operations}

The goal of this section is to provide a protocol for demonstrating disjointness of multiple data sets/multisets. The proofs can be publicly verified against the succinct commitments to these multisets. To that end, we first describe a protocol whereby an honest Prover can show that the GCD of two discrete logarithms equals a third discrete logarithm while keeping the communication complexity constant. One obvious application is proving disjointness of sets/multisets in accumulators instantiated with hidden order groups. We formulate an HVZK argument of knowledge for the relation \vs  $$\mc{R}_{{\ttt{GCD}}}[(a_1,b_1),\;(a_2,b_2),\;(a_3,b_3)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=d_3  \} . \vs $$ We construct a protocol that has communication complexity independent of the elements $a_i, b_i$. The protocol rests on the basic fact that \vs $$d_3 = \GCD(d_1, d_2)\;\; \LRA \;\;(d_1\equiv d_2\equiv 0 \Mod{d_3})\;\bigwedge \; \left(\exists \; (x_1,x_2)\in \bz^2:\; d_3 = x_1d_1+x_2d_2  \right).$$
 

\begin{Prot} \normalfont \hypertarget{GCD}{\textit{Zero knowledge proof of the greatest common divisor}} (\verb|ZKPoGCD|):\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Input:} Elements $a_1, a_2, a_3, b_1, b_2, b_3 \in \mb{G}$.

\noin \textbf{Claim:} The Prover possesses integers $d_1$, $d_2$, $d_3$ such that:

\noin - $a_1^{d_1} = b_1$, $a_2^{d_2} = b_2$, $a_3^{d_3} = b_3$\\
\noin - $\GCD(d_1, d_2) = d_3$
 

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mc{P}$ computes $b_{1,2}:= a_1^{d_2}\;,\; b_{1,3}:= a_1^{d_3}\;\in\;\bG$ and sends them to the Verifier $\V$.

\noin 2. $\mP$ generates non-interactive proofs for \verb|ZKPoEqDLog|$[(a_2, b_2),\; (a_1, b_{1,2})]$, \verb|ZKPoEqDLog|$[(a_3, b_3),\; (a_1, b_{1,3})]$ and sends them to $\mc{V}$.

\noin 3. $\mc{P}$ generates non-interactive proofs for \verb|ZKPoKE|$[b_{1,3},\;b_1 ]$ and \verb|ZKPoKE|$[b_{1,3},\;b_{1,2} ]$ and sends them to $\V$.\\
\noin 3. $\mc{P}$ uses the Euclidean algorithm to compute integers $e_1, e_2$ such that \vs $$e_1d_1 + e_2d_2 = d_3\;\;,\;\; |e_1| < |d_2|\;,\; |e_2| < |d_1|. \vs $$

\noin 5. $\mc{P}$ computes $$\wti{b}_1:= b_1^{e_1}\;,\; \wti{b}_{1,2}:= b_{1,2}^{e_2}\;\in\;\bG \vs $$ and sends them to $\V$ along with non-interactive proofs for \verb|ZKPoKE|$[b_1,\; \wti{b}_1]$ and \verb|ZKPoKE|$[b_{1,2},\; \wti{b}_{1,2}]$.

\noin 6. $\mc{V}$ verifies all of the proofs he receives in addition to the equation \vs $$\wti{b}_1\cdot \wti{b}_{1,2}\stackrel{?}{=} b_{1,3}\;\in\;\bG. \vs $$ He accepts the validity of the claim if and only if all of these proofs are valid.\qed \end{enumerate}



\begin{Thm}\label{GCDProof} \hyperlink{GCD}{The Protocol $\tt{ZKPoGCD}$} is an HVZK argument of knowledge for the relation $\mc{R}_{{\tt{GCD}}}$ in the generic group model.\end{Thm}

\begin{prf} \end{prf}


\noin An important special case is where $\GCD(d_1, d_2) = 1$. In this case, Step 3 is redundant and hence, the proof size is smaller. We call this special case the Protocol for \textit{Relatively Prime Discrete Logarithms} or \verb|RelPrimeDLog| for short:\vs \[\mc{R}_{{\ttt{RelPrimeDLog}}}[(a_1,b_1),\;(a_2,b_2)] = \big\{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=1 \big\} .\] 



\begin{Prot} \normalfont \hypertarget{GCDPed}{\textit{ZK Proof of GCD}} (\verb|ZKPoRelPrimeDLog|):\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Input:} Elements $a_1, a_2, b_1, b_2 \in \mb{G}$. 

\noin \textbf{Claim:} The Prover possesses integers $d_1$, $d_2$ such that:

\noin - $a_1^{d_1} = b_1$, $a_2^{d_2} = b_2$\\
\noin - $\GCD(d_1, d_2) = 1$
 

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mc{P}$ computes $b_{1,2}:= a_1^{d_2}$ and sends it to the Verifier $\V$ along with a\\ non-interactive proof for \verb|ZKPoEqDLog|$[(a_2, b_2),\; (a_1, b_{1,2})]$.

\noin 2. $\mc{P}$ uses the Euclidean algorithm to compute integers $e_1, e_2$ such that $e_1d_1 + e_2d_2 = 1$.

\noin 3. $\mc{P}$ computes \vs $$\wti{b}_1:= b_1^{e_1}\;\;,\;\; \wti{b}_{1,2}:= b_{1,2}^{e_2}\;\in\;\bG \vs $$ and sends them to $\V$ along with non-interactive proofs for \verb|ZKPoKE|$[b_1,\; \wti{b}_1]$ and \verb|ZKPoKE|$[b_{1,2},\; \wti{b}_{1,2}]$.

\noin 4. $\mc{V}$ verifies the equation $\wti{b}_1\cdot\wti{b}_{1,2}\stackrel{?}{=} a_1\in\bG $ and the proofs for \verb|ZKPoEqDLog|$[(a_2, b_2),\; (a_1, b_{1,2})]$, \verb|ZKPoKE|$[b_1,\; \wti{b}_1]$ and \verb|ZKPoKE|$[b_{1,2},\; \wti{b}_{1,2}]$. He accepts the validity of the claim if and only if all of these proofs are valid.\qed \end{enumerate}

\vspace{0.1cm}

\begin{Prop} The Protocol \verb|ZKPoRelPrimeDLog| is a HVZK argument for the relation\\ $\mc{R}_{{\tt{RelPrimeDLog}}}$ in the generic group model.\end{Prop}

\begin{prf} This is a special case of Proposition \ref{GCDProof}.\end{prf}

The protocol $\tt{ZKPoGCD}$ can also be adapted for Pedersen commitments to sets or multisets. Suppose $ a_i:= g^{d_i}h^{r_i}\in \bG $ ($i=1,2,3$) where the $d_i$ are integers such that $\GCD(d_1,d_2) = d_3$ and the $r_i$ are randomly selected integers. The Prover can demonstrate that $\GCD(d_1,d_2) = d_3$ as follows, without revealing anything about the integer $d_i$. We provide an HVZK argument of knwoledge for the relation \[
  \mc{R}_{{\ttt{PolyDLogPed}}}[a_1,a_2,a_3] = \left\{\begin{array}{l}
    \big(a_1,a_2,a_3\in\mb{G},\;\mbf{f}\in\bz[X]\big);\\
    (d_1, d_2,d_3, e_1,e_2, e_6)\in\mb{Z}^6): \\
    a_i = g^{d_i}h^{e_i}\;\forall\;\i\;\; \bigwedge\;\; \GCD(d_1,d_2) = d_3  \end{array}\right\}
\] 

\begin{Prot} \normalfont \hypertarget{GCDPedersen}{\textit{Zero knowledge proof of the GCD for Pedersen commitments}} (\verb|ZKPoGCDPed|):\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Input:} Elements $a_1, a_2, a_3\in \mb{G}$.

\noin \textbf{Claim:} The Prover possesses integers $d_i$, $r_i$ ($i=1,2,3$) such that:

\noin - $a_i = g^{d_i}h^{r_i}$\\
\noin - $\GCD(d_1, d_2) = d_3$

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item $\mP$ computes the integers $d_{1,3}:= d_1\cdot d_3^{-1}$, $d_{2,3}:= d_2\cdot d_3^{-1}$ and sends \vs $$a_{1,3}:= a_3^{d_{1,3}}\;,\;a_{1,3}:= a_3^{d_{1,3}}\;\in\;\bG \vs $$ to $\V$ along with non-interactive proofs for $\ttt{ZKPoKE}[a_3,\;a_{1,3}]$, $\ttt{ZKPoKE}[a_3,\;a_{2,3}]$.

\noin 2. $\mP$ computes \vs $$h_{1,3}:= h^{r_1 - d_{1,3}\cdot r_3}\;,\; h_{2,3}:= h^{r_2 - d_{2,3}\cdot r_3}\;\in\;\bG\vs $$ and sends non-interactive proofs for $\ttt{ZKPoKE}[h,\;h_{1,3}]$, $\ttt{ZKPoKE}[h,\;h_{2,3}]$ to $\V$.

\noin 3. $\mP$ computes integers $e_1$, $e_2$ such that $e_1d_1+e_2d_2 = d_3$. 

\noin 4. $\mP$ computes \vs $$ \wti{a}_1:= a_1^{e_1}\;,\;  \wti{a}_2:= a_2^{e_2}\;\in\;\bG \vs $$ and sends them to $\V$ along with non-interactive proofs for $\ttt{ZKPoKE}[a_1,\wti{a}_1]$, $\ttt{ZKPoKE}[a_2,\wti{a}_2]$.

\noin 5. $\mP$ computes $\wti{h}:= h^{e_1r_1+e_2r_2-r_3}\in \bG$ and sends it to $\V$ along with a non-interactive proof for $\ttt{ZKPoKE}[h,\;\wti{h}]$.

\noin 6. $\V$ verifies the five \verb|ZKPoKE|s he receives in addition to the equations \vs $$ \wti{a}_1\cdot \wti{a}_2\sta a_3 \;\;\bigwedge\;\;a_{1,3}\cdot h_{1,3}\sta a_1 \;\;\bigwedge\;\;a_{2,3}\cdot h_{2,3}\sta a_2 . \vs $$ He accepts if and only if all equations hold and all five \verb|ZKPoKE|s are valid.\qed \end{enumerate}

Given Pedersen commitments $A_i:= g^{\Pi(\mc{D}_i)}h^{r_i}\in \bG $ to sets or multisets $\mc{D}_i$ such that $\mc{D}_1\cap \mc{D}_2 = \mc{D}_3$, the last protocol allows a Prover to succinctly demonstrate this relation    without revealing anything about the $\mc{D}_i$. The communication complexity is constant, as is the Verifier's runtime.


\bigskip




It is easy to see that the protocols \verb|ZKPoGCD| may be combined with the protcol \verb|ZKPoProd| to provide an HVZK argument of knowledge for the relation \vs \[ \mc{R}_{{\ttt{LCM}}}[(a_1,b_1),\;(a_2,b_2), \; (a_3, b_3)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\LCM(d_1,d_2)=d_3 \} .\] This argument of knowledge can demonstrate that for data sets/multisets $\mc{D}_1,\mc{D}_2, \mc{D}_3$, we have \vs $$\mc{D}_3 = \mc{D}_1\cup \mc{D}_2 \vs $$ by setting \vs $$ d_i = \prod\limits_{d\in\mc{D}_i} x\;\;(i=1,2,3). $$

\vspace{0.1cm}


\begin{Prot} \normalfont \hypertarget{LCM}{\textit{Zero knowledge proof of LCM}} (\verb|ZKPoLCM|):\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Input:} Elements $a, b_1, b_2, b_3 \in \mb{G}$.

\noin \textbf{Claim:} The Prover possesses integers $d_1$, $d_2$, $d_3$ such that:

\noin - $a^{d_1} = b_1$, $a^{d_2} = b_2$, $a^{d_3} = b_3$\\
\noin - $\LCM(d_1, d_2) = d_3$
 

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ computes $b_{\ttt{gcd}}:= a^{\GCD(d_1,d_2)}\in \bG$ and sends $b_{\ttt{gcd}}$ to the Verifier $\V$ along with a non-interactive proof for $\ttt{ZKPoGCD}[(a,b_1),\;(a,b_2),\;(a,b_{\ttt{gcd}})]$.

\noin 2. $\mP$ computes $b_{\ttt{prod}}:= a^{d_1d_2}\in \bG$ and sends it to $\V$ along with a non-interactive proof for $\ttt{ZKPoProd}[(a, b_1), (a, b_2), (a,b_{\ttt{prod}})]$.

\noin 3. $\mP$ generates a non-interactive proof for $\ttt{ZKPoProd}[(a, b_{\ttt{gcd}}),\;(a, b_3),\; (a,b_{\ttt{prod}})]$ and sends it to $\V$.

\noin 4. $\V$ verifies the three proofs and accepts if and only if they are all valid.\qed \end{enumerate}




\noin The HVZK arguments of knowledge for the GCD and the product can be combined to get an HVZK argument of knowledge for the difference of two sets or multisets.

\begin{Prot} ZK Protocol for multiset differences $(\tt{ZKPoDiff})$\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Input:} Elements $a, b_1, b_2, b_3 \in \mb{G}$.

\noin \textbf{Claim:} The Prover possesses integers $d_1$, $d_2$, $d_3$ such that:

\noin - $a^{d_1} = b_1$, $a^{d_2} = b_2$, $a^{d_3} = b_3$\\
\noin - $d_1 = d_3\cdot \GCD(d_1,d_2)$
 

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ computes $b_{\ttt{gcd}}:= a^{\GCD(d_1,d_2)}\in \bG$ and sends to the Verifier $\V$ along with a non-interactive proof for $\ttt{ZKPoGCD}[(a,b_1),\;(a,b_2),\;(a,b_{\ttt{gcd}})]$.

\noin 2. $\mP$ generates a non-interactive proof for $\ttt{ZKPoProd}[(a, b_{\ttt{gcd}}),\;(a, b_3),\;(a,b_1)]$ and sends it to $\V$.

\noin 3. $\V$ verifies the three proofs and accepts if and only if they are all valid.\qed \end{enumerate}




%\section{\fontsize{11}{11}\selectfont HVZK for sets for hiding commitments}








\newpage


\noin \Large \textbf{References} \vspace{0.2cm}
\footnotesize


\noin \hypertarget{BBF19}[BBF19] Dan Boneh, Benedikt B\"{u}nz, Ben Fisch, \textit{Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains.} In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology – Crypto 2019, pages 561–586, Cham, 2019. Springer International Publishing. \vspace{0.1cm}

\noin [BBBF18] Dan Boneh, Joseph Bonneau, Benedikt B\"{u}nz and Ben Fisch, \textit{Verifiable delay functions}. In Hovav Shacham and Alexandra Boldyreva, editors, Crypto 2018, Part I, volume 10991 of LNCS \vspace{0.1cm}

\noin [BBF18] Dan Boneh, Benedikt B\"{u}nz, and Ben Fisch, \textit{A survey of two verifiable delay functions}. Cryptology ePrint Archive, Report 2018/712, 2018. \href{https://eprint.iacr.org/2018/712}{https://eprint.iacr.org/2018/712} \vspace{0.1cm}

\noin \hypertarget{BFS19}{[BFS19]} Benedikt B\"{u}nz, Ben Fisch, Alan Szepieniec, \href{https://eprint.iacr.org/2019/1229}{\textit{Transparent SNARKs from DARK Compilers}}, Cryptology ePrint Archive, Report 2019/1229, 2019.  \vspace{0.1cm}

\noin [BCM05] Endre Bangerter, Jan Camenisch, and Ueli Maurer. \textit{Efficient proofs of knowledge of discrete logarithms and representations in groups with hidden order}. In Serge Vaudenay, editor, PKC 2005, volume 3386 of LNCS, Springer, Heidelberg, January 2005.\vspace{0.1cm}

\noin \hypertarget{BCS16}{[BCS16]} Eli Ben-Sasson, Alessandro Chiesa, Nicholas Spooner. \textit{Interactive oracle proofs}. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31-60. Springer, Heidelberg,
October/November 2016.\vspace{0.1cm}

\noin \hypertarget{BD94}{[BD94]} Josh Cohen Benaloh and Michael de Mare. \textit{One-way accumulators: A decentralized alternative to digital sinatures} (extended abstract). In Tor Helleseth, editor, Eurocrypt'93, volume 765 of LNCS, pages 274-285. Springer, Heidelberg, May 1994.\vspace{0.1cm}

\noin \hypertarget{BH01}{[BH01]} Johannes Buchmann and Safuat Hamdy. \textit{A survey on IQ cryptography}, In Public-Key Cryptography and Computational Number Theory. \vspace{0.1cm}

\noin [BKSW20] Karim Belabas, Thorsten Kleinjung, Antonio Sanso, Benjamin Wesolowski, \href{https://eprint.iacr.org/2020/1310}{\textit{A note on the low order assumption in class group of an imaginary quadratic number fields}, Preprint} \vspace{0.1cm}

\noin \hypertarget{BP97}{[BP97]} Niko Bari and Birgit Pfitzmann. \textit{Collision-free accumulators and fail-stop signature schemes without trees}. In Walter Fumy, editor, Eurocrypt'97, volume 1233 of LNCS, pages 480-494. Springer, Heidelberg, May 1997. \vspace{0.1cm}

\noin \hypertarget{BS96}{[BS96]} Wieb Bosma and Peter Stevenhagen. \textit{On the computation of quadratic 2-class groups} In Journal de Theorie des Nombres, 1996. \vspace{0.1cm}

\noin [CF13] Dario Catalano and Dario Fiore. \textit{Vector commitments and their applications}, In Kaoru Kurosawa and Goichiro Hanaoka, editors, PKC 2013, volume 7778 of LNCS, pages 55-72. Springer, Heidelberg, February/March 2013. \vspace{0.1cm}

\noin \hypertarget{CFGKN20}{[CFGKN20]} Matteo Campanelli, Dario Fiore, Nicola Greco, Dimitris Kolonelos, Luca Nizzardo, \href{https://eprint.iacr.org/2020/149}{\textit{Vector Commitment Techniques and Applications to Verifiable Decentralized Storage}} \vspace{0.1cm}

%\noin [CSV20] W. Castryck, J, Sotakova, F. Vercauteren, \href{https://eprint.iacr.org/2020/151}{\textit{Breaking the decisional Diffie-Hellman problem for class group actions using genus theory}}\vspace{0.1cm}

\noin [Can87] David Cantor. \textit{Computing in the Jacobian of a hyperelliptic curve. Mathematics of computation}, 1987.\vspace{0.1cm}

\noin [Can94] David Cantor. \textit{On the analogue of the division polynomials for hyperelliptic curves}, Crelle's Journal, 1994.\vspace{0.1cm}

\noin \hypertarget{DGS20}{[DGS20]} Samuel Dobson, Steven Galbraith, Benjamin Smith, \href{https://eprint.iacr.org/2020/196}{\textit{Trustless Groups of Unknown Order with Hyperelliptic Curves}} \vspace{0.1cm}

\noin \hypertarget{{DK02}}{[DK02]} Ivan Damgard and Maciej Koprowski. \textit{Generic lower bounds for root extraction and signature schemes in general groups}. In Lars R. Knudsen, editor, Eurocrypt 2002, volume 2332 of LNCS, pages 256-271. Springer, Heidelberg, April / May 2002.\vspace{0.1cm}

% \noin [Fis18] Ben Fisch. \textit{Tight Proofs of Space and Replication}. In Y. Ishai and V. Rijmen, editors, Eurocrypt 2019, Part II, volume 11477 of LNCS, pages 324-348. Springer, Heidelberg, May 2019. \vspace{0.1cm}

\noin \hypertarget{FS87}{[FS87]} Amos Fiat and Adi Shamir. \textit{How to prove yourself: Practical solutions to identification and signature problems.} Crypto’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987\vspace{0.1cm}

% \noin [HM00] Safuat Hamdy and Bodo Moller. \textit{Security of cryptosystems based on class groups of imaginary quadratic orders.} ASIACRYPT 2000, volume 1976 of LNCS, pages 234-247. Springer, Heidelberg, December 2000.\vspace{0.1cm}

% \noin [KPZ17] N. Katz, C. Papamanthou, Y. Zhang, \textit{An Expressive (Zero-Knowledge) Set Accumulator}, 2017 IEEE European Symposium on Security and Privacy \vspace{0.1cm}

\noin [Lip12] Helger Lipmaa. \textit{Secure accumulators from euclidean rings without trusted setup.} ACNS 12, volume 7341 of LNCS, pages 224{240. Springer, Heidelberg, June 2012.\vspace{0.1cm}

\noin [LLX07] Jiangtao Li, Ninghui Li, and Rui Xue.  \textit{Universal accumulators with efficient nonmembership proofs} ACNS 07, volume 4521 of LNCS, pages 253-269. Springer, Heidelberg, June 2007.\vspace{0.1cm}

% \noin [LM18] Russell W.F. Lai and Giulio Malavolta,  \textit{Optimal succinct arguments via hidden order groups}. Cryptology ePrint Archive, Report 2018/705, 2018. \vspace{0.1cm}

\noin [Mic94] Silvio Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436-453. IEEE Computer Society Press, November 1994.\vspace{0.1cm}

% \noin [Ngu05] L. Nguyen. \textit{Accumulators from bilinear maps and applications}. CT-RSA, 2005. \vspace{0.1cm}

\noin [Sha83] Adi Shamir. \textit{On the generation of cryptographically strong pseudorandom
sequences}. ACM Transactions on Computer Systems (TOCS), 1983 \vspace{0.1cm}.

\noin \hypertarget{Sho97}{[Sho97]} Victor Shoup, \textit{Lower bounds for discrete logarithms and related problems}. Eurocrypt'97, volume 1233 of LNCS, pages 256{266. Springer, Heidelberg, May 1997. \vspace{0.1cm}

\noin \hypertarget{Sut07}{[Sut07]} Andrew Sutherland, \textit{Order Computations in Generic Groups}, MIT Thesis, 2007 \vspace{0.1cm}

\noin \hypertarget{STY01}{[STY01]} Tomas Sander, Amnon Ta-Shma, Moti Yung, \textit{Blind, auditable membership proofs}, FC 2000, volume 1962 of LNCS, pages 53{71. Springer, Heidelberg, February 2001.\vspace{0.1cm}

%\noin [Th19] S. Thakur, \textit{Batching non-membership proofs with bilinear accumulators}, https://eprint.iacr.org/2019/1147\vspace{0.1cm}

\noin [Th20A] Steve Thakur, \href{https://eprint.iacr.org/2020/348}{\textit{Constructing hidden order groups using genus three Jacobians}}, Preprint \vspace{0.1cm}

\noin \hypertarget{Th20}{[Th20B]} Steve Thakur, \href{https://eprint.iacr.org/2020/1617}{\textit{Arguments of Knowledge in hidden order groups}}, Preprint \vspace{0.1cm} 

% \noin \hypertarget{Tod16}{[Tod16]} Peter Todd. \textit{Making UTXO Set Growth Irrelevant With Low-Latency Delayed TXO Commitments}.\\ https://petertodd.org/2016/delayed-txo-commitments, May 2016.\vspace{0.1cm}

\noin \hypertarget{Wes18}{[Wes19]} Benjamin Wesolowski, \textit{Efficient verifiable delay functions}. Advances in Cryptology – Eurocrypt 2019, pages 379–407, Cham, 2019. Springer International Publishing.\vspace{0.1cm}




\bigskip

\normalsize

\noin Steve Thakur\\
Axoni Research Group\\
New York City, NY\\
Email: stevethakur01@gmail.com 


\newpage

\appendix

\section{\fontsize{11}{11}\selectfont List of Protocols:}

\hypertarget{List}{The following is a list of the protocols in this paper and the relations that the protocols are HVZK arguments of knowledge for, in the generic group model. In each of the protocols, we may replace $\bz$ by the localization $\bz_{\mc{S}}$ at any set $\mc{S}$ of rational primes.}

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]

\item $\ttt{ZKPoEqDLog}$ (\textit{Proof of equality of discrete logarithms}) \vspace{-0.3cm}

\[
  \mc{R}_{{\ttt{EqDLog}}}[(a_1, b_1),\;(a_2,b_2)] = \left\{\begin{array}{l}
    ((a_1, b_1), \; (a_2,b_2)\in\mb{G}^2\\
    d\in\mb{Z}): \\
    (b_1,b_2) = (a_1^d,a_2^d)
  \end{array}\right\}
\]

 

\item $\ttt{ZKPoPolyDLog}$ (\textit{Proof of polynomial relation between} (\textit{two}) \textit{discrete logarithms})\vspace{-0.3cm}

\[
  \mc{R}_{{\ttt{PolyDLog}}}[(a_1, b_1),\;(a_2,b_2),\;f] = \left\{\begin{array}{l}
    ((a_1, b_1), \; (a_2,b_2)\in\mb{G}^2,\;f\in\bz[X]);\\
    (d_1, d_2)\in\mb{Z}^2: \\
    b_1 = a_1^{d_1}\; \bigwedge\; b_1 = a_1^{d_1}\; \bigwedge \;d_2 = f(d_1)
  \end{array}\right\}
\]

\item \hyperlink{GCD}{$\ttt{ZKPoProd}$ (\textit{Proof of Product})} \vspace{-0.15cm} $$\mc{R}_{{\ttt{Prod}}}[(a_1,b_1),\; (a_2,b_2),(a_3,b_3)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;d_1d_2 = d_3  \} \vs $$


\item \hyperlink{GCD}{$\ttt{ZKPoGCD}$ (\textit{Proof of GCD})} \vspace{-0.15cm} $$\mc{R}_{{\ttt{GCD}}}[(a_1,b_1),\; (a_2,b_2),(a_3,b_3)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=d_3  \} \vs $$


\item \hyperlink{RP}{$\ttt{ZKPoRelPrimeDLog}$ (\textit{Proof of relatively prime discrete logarithms}; special case of $\tt{PoGCD}$)} \vs $$ \mc{R}_{\ttt{RelPrimeDLog}}[(a_1,b_1),\;(a_2,b_2)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=1 \} . \vs $$


\item \hyperlink{LCM}{$\ttt{ZKPoLCM}$ (\textit{Proof of LCM})} \vspace{-0.15cm} $$\mc{R}_{{\ttt{LCM}}}[(a_1,b_1),\; (a_2,b_2),(a_3,b_3)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\LCM(d_1,d_2)=d_3  \} \vs $$


\item \hyperlink{RP}{$\ttt{ZKPoRelPrimeDLog}$ (\textit{Proof of relatively prime discrete logarithms}; special case of $\tt{PoGCD}$)} \vs $$ \mc{R}_{\ttt{RelPrimeDLog}}[(a_1,b_1),\;(a_2,b_2)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=1 \} . \vs $$


\item \hyperlink{Sets}{\textit{Zero-knowledge proof of the containment/non-containment of the underlying sets}}\vspace{-0.3cm}

%\noin If the Verifier has access to the commitments $\ttt{Com}(g, \mcM_i)= g^{\Pi(\mcM_i)}$ for multisets $\mcM_1, \mcM_2$, the Prover can verifiably show whether $\sett(\mcM_1)\sub \sett(\mcM_2)$ or $\sett(\mcM_1)\not\sub \sett(\mcM_2)$.\vspace{0.1cm}

\[
  \mc{R}_{\ttt{ConSets}}[(a_1, A_1),\;(a_2,A_2)] = \left\{\begin{array}{l}
    (a_1,a_2, A_1, A_2\;\in\;\mb{G}; \\
    (d_1, d_2, N) \in \bz^3):   \\
    a_1^{d_1} = A_1\;\wedge\;a_2^{d_2} = A_2\\
    \;\wedge\;d_2^{N}\equiv 0\Mod{d_1} 
  \end{array}\right\}
\]


\[
  \mc{R}_{\ttt{NonConSets}}[(a_1, A_1),\;(a_2,A_2)] = \left\{\begin{array}{l}
    (a_1,a_2, A_1, A_2\;\in\;\mb{G}; \\
    (d_1, d_2, p) \in \bz^3):   \\
    a_1^{d_1} = A_1\;\wedge\;a_2^{d_2} = A_2\;\wedge\\
   p \big| d_2\; \wedge\; p \big| d_1 \; \wedge\; p\neq \pm 1 
  \end{array}\right\}
\]


\end{enumerate}



\section{\fontsize{11}{11}\selectfont Pedersen Commitments}


\begin{Prot} \normalfont \hypertarget{PolyPed}{\textit{Zero knowledge proof of polynomial relation between discrete logarithms for Pedersen commitments}}(\verb|ZKPoPolyDLogPed|):\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Inputs:} Elements $a,b \in \mb{G}$; a public univariate polynomial $\mbf{f}(X)\in \bz[X]$; $B > 2^{2\lam}|\bG|$

\noin \textbf{Claim:} The Prover possesses integers $d$, $e$, $\what{e}$ ($i=1,2$) such that $a = g^dh^e$, $b = g^{\mbf{f}(d)}h^{\what{e}}$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ chooses random $k, e_1\in[-B,B]$ and sends $A_1:= g^{k}h^{e_1}\in \bG$ to the Verifier $\V$.

\noin 2. The hashing algorithm $\ttt{H}_{\ttt{FS},\lam}$ generates a $\lam$-bit prime $\gamma$.

\noin 3. $\mP$ chooses a random $e_2 \in [-B,B]$ and sends $A_2:= g^{\mbf{f}(d_1+k\gamma)}\cdot h^{e_2}\in \bG$ to $\V$.

\noin 4. $\mP$ computes \vs $$\wti{e}:= e_2-\what{e}\Mod{e_1\cdot \gamma}\;\;,\;\;\wti{h}:= h^{\what{e}}\in \bG\vs $$ and sends $\wti{h}$ to $\V$ along with a non-interactive proof for $\ttt{ZKPoKE}[h,\; \wti{h}]$ and $\ttt{ZKPoKE}[A_1^{\gamma},\;A_2\cdot b^{-1}\cdot \wti{h}^{-1}] $.

\noin 5. The hashing algorithm $\ttt{H}_{\ttt{FS},\lam}$ generates a $\lam$-bit prime $\ell$. 

\noin 6. $\mP$ computes the integers $q_1$, $r_1$, $q_2$, $r_2$, $q_1'$, $s_1$, $q_2'$, $s_2$ such that $r_1,r_2,s_1,s_2\in [\ell]$ and \vs $$d+k\gamma = q_1\cdot \ell + r_1\;,\; \mbf{f}(d+k\gamma) = q_2\cdot \ell + r_2 \;,\;\;e_1 = q_1'\cdot \ell+s_1 \;,\;\;e_2 = q_2'\cdot \ell+s_2 \vs $$ and sends $r_1 ,s_1, s_2\in [\ell]^3$, $Q_1:= g^{q_1}h^{q_1'}\;,\; Q_2:= g^{q_2}h^{q_2'}\in \bG$ to $\V$.

\noin 7. $\V$ verifies that $r_1 ,s_1, s_2\in [\ell]^3$ and computes $r_2:= \mbf{f}(r_1)\Mod{\ell}$.

\noin 8. $\V$ verifies the two $\tt{ZKPoKE}$s he receives and verifies the equations \vs $$ Q_1^{\ell}\cdot g^{r_1}\cdot h^{s_1}\sta a\cdot A_1^{\gamma} \;\;\bigwedge\;\; Q_2^{\ell}\cdot g^{r_2}\cdot h^{s_2}\sta    A_2 .\vs $$ He accepts if and only if all equations hol and the two $\tt{ZKPoKE}$s are valid.\qed\end{enumerate}


We provide a HVZK argument of knowledge for the relation \[
  \mc{R}_{{\ttt{PolyDLogPed}}}[a,b,\;\mbf{f}] = \left\{\begin{array}{l}
    \big(a,b\in\mb{G},\;\mbf{f}\in\bz[X]\big);\\
    (d_1, d_2, e_1,e_2)\in\mb{Z}^4): \\
    a = g^{d_1}h^{e_1}\; \bigwedge\; b = g^{d_2}h^{e_2}\; \bigwedge \;d_2 = \mbf{f}(d_1)
  \end{array}\right\}
\] 





\begin{Prot} \normalfont \hypertarget{PoProdPed}{\textit{Zero knowledge proof of product of discrete logarithms for Pedersen commitments}} (\verb|ZKPoProdPed|):\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Inputs:} Elements $a_1,a_2,a_3\in \mb{G}$

\noin \textbf{Claim:} The Prover possesses integers $d_i$, $e_i$ ($i=1,2,3$) such that $a_i = g^{d_i}h^{e_i}$ and $d_1d_2 = d_3$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ computes $\what{a}_3:= a_1^{d_2} = g^{d_3}h^{e_1d_2}\in \bG$ and sends it to the Verifier $\V$.

\noin 2. $\mP$ chooses a random integer $k\in [-B, B]$ and sends $\what{h}:= h^k$ to $\V$ along with a non-interactive proof for $\ttt{ZKPoKE}[h,\;\what{h}]$.

\noin 3. $\mP$ computes $\what{a}_2:= (g\what{h})^{d_2}$ and sends $\what{a}_2$ to $\V$ along with a non-interactive proof for\\ $\ttt{ZKPoEqDLog}[(a_1,\what{a}_3),\;(g\cdot\what{h}, \what{a}_2)]$

\noin 4. $\mP$ computes $\wti{h}_2:= h^{e_2-k\cdot d_2}\;$, $\;\wti{h}_3:= h^{e_3-e_1\cdot d_2}$ and sends $\wti{h}_2$, $\wti{h}_3$ to $\V$ along with non-interactive proofs for $\ttt{ZKPoKE}[h,\;\wti{h}_2 ]$, $\ttt{ZKPoKE}[h,\;\wti{h}_3 ]$.

\noin 5. $\V$ verifies the three $\tt{ZKPoKE}$s and the one $\ttt{ZKPoEqDLog}$ he receives. He then verifies the equations \vs $$ \what{a}_2\cdot \wti{h}_2 \sta a_2\;\;\bigwedge\;\;\what{a}_3\cdot \wti{h}_3 \sta a_3. \vs $$ He accepts if and only if both equations hold and all three $\tt{ZKPoKE}$s and the $\ttt{ZKPoEqDLog}$ are valid.\qed \end{enumerate}


We provide a HVZK argument of knowledge for the relation \[
  \mc{R}_{{\ttt{LCMPed}}}[a_1,a_2,a_3] = \left\{\begin{array}{l}
    \big(a_1,a_2,a_3\in\mb{G} \big);\\
    (d_1, d_2,d_3, e_1,e_2,e_3)\in\mb{Z}^6): \\
    a_i = g^{d_1}h^{e_1}\;\forall\;i\;\; \bigwedge\;\; \LCM(d_1,d_2) = d_3   \end{array}\right\}
\] 


Given Pedersen commitments to sets or multisets $\mc{D}_i$ ($i=1,2,3$) such that $\mc{D}_1\cup \mc{D}_2 = \mc{D}_3$, the protocol allows a Prover to demonstrate this relation without revealing anything about the $\mc{D}_i$.



\begin{Prot} \normalfont \hypertarget{PoLCMPed}{\textit{Zero knowledge proof of LCM for Pedersen commitments}} (\verb|ZKPoLCMPed|):\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,  $g,h\in \mb{G}$ such that $\la g \ra = \la h \ra$.

\noin \textbf{Inputs:} Elements $a_1,a_2,a_3\in \mb{G}$

\noin \textbf{Claim:} The Prover possesses integers $d_i$, $e_i$ ($i=1,2,3$) such that $a_i = g^{d_i}h^{e_i}$ and $\LCM(d_1,d_2) = d_3$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ chooses a random integer $e_{\ttt{GCD}}$ and sends $a_{\ttt{GCD}}:= g^{\GCD(d_1,d_2)}h^{e_{\ttt{GCD}}}$ to the Verifier $\V$ along with a non-interactive proof for $\ttt{ZKPoGCDPed}[a_1,a_2,a_{\ttt{GCD}}]$.

\noin 2. $\mP$ chooses a random integer $e_{\ttt{prod}}$ and sends $a_{\ttt{prod}}:= g^{d_1d_2}h^{e_{\ttt{prod}}}$ to the Verifier $\V$ along with a non-interactive proof for $\ttt{ZKPoProdPed}[a_1,a_2,a_{\ttt{prod}}]$.

\noin 3. $\mP$ generates a non-interactive proof for $\ttt{ZKPoProdPed}[a_3,a_{\ttt{GCD}}, a_{\ttt{prod}}]$ and sends it to $\V$.

\noin 4. $\V$ verifies the three proofs he receives and accepts if and only if they are all valid.\qed \end{enumerate}

 






\begin{comment}

# Shrouded Socket

Take Home Test

## Rules



We care about clean code, comments documenting assumptions/design choices/edge cases/..., and maybe even some tests. :-) 
Please make sure to document how to compile and run your code.

We should have granted you access to a private GitHub repository to share your work with us. If we did not, please reach out!

## Task Description

Alice wishes to receive confidential and authenticated data from a set of other parties (Bob, Charlotte, Dave, ...) whose identities she knows. To this end, she has set up a server that receives data over a TLS based protocol. Bob, Charlotte, ... run clients that communicate with Alice's server.

This leaves Alice with a problem. Her certificate is publicly known and her server is exposed on the public internet. An attacker looking to find Alice's server could easily scan the entire IPv4 internet to find it (and subsequently mount a DDoS attack against it). Alice wants to *hide* her server: known parties that know her server's address should be able to connect, but the server should reveal as little information as possible to unknown parties. Can you help Alice?

Design and implement a protocol that allows Alice's server to expose a _shrouded socket_. The shrouded socket protocol should work as follows:
- On initiating a TCP connection to Server, Client will first send a special `unlock` message generated using Client's secret key.
- Server will then verify that the unlock message is valid and belongs to one of the Clients whose public keys are on an allow list.
	- If the verif ication succeeds, the connection 			should be upgraded to a regular TLS connection.
	- If the verification fails, the connection should 		be closed. No TLS handshake takes place, and 			therefore the Server certificate is not revealed.

You should:
- design a shrouded socket protocol (in particular the `unlock` message) and document design concerns and decisions you made. You can use comments in your code or a separate file. Provide some reasoning for your design choices.
- implement a server for the protocol
- implement a client for the protocol

Feel free to use external libraries for TLS/cryptography. You may generate certificates/keypairs in whatever format is easiest for your application to consume. To make your life easier, you may assume that the confidential data that is being sent by the clients is `"HI ALICE"`. (We care about the connection establishment process, not about the data being sent.)

Hint: Certificates are not the only way to fingerprint a server. Think carefully about other means of fingerprinting and possible side channels. To make your life easier, you may assume that timing side channels whose exploitation requires collecting many samples are out of scope, though we'd appreciate you pointing them out.







https://www.geeksforgeeks.org/implementation-diffie-hellman-algorithm/








\end{comment}











\end{document}